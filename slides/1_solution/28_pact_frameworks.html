<h2 style="text-transform: none;">Consumer-Driven Contracts</h2>
<div style="visibility: hidden; margin-top: 500px;">ORLY</div>

<aside class="notes">
    <p>Дима:</p>
    <blockquote>
        В двух словах этот подход состоит из 2 простых шагов:
        1) Мы пишем компонентные тесты с моком (Для Консьюмера), после прогона мы генерируем "контракт" просто записываем все запросы и ответы от мока в
           файл (если мы используем Pact это Pact файл)
        2) Проверяем что сервис который мы замокали (Провайдер) отвечает АБСОЛЮТНО так же, идем по файлу и делаем все те запросы что и реальный сервис,
           и сравниваем ответы.

        Есть множество способов как провайдер может получить контракт, во первых это файл и его можно хранить в репозитории,
        его можно хранить на файловом хранилище и клучший вариант это использование Pact Broker'а это сервис для хранения и версионирования
        Pact файлов.

        И Естественно нам может потребоваться определенное сосотояние в провайдере чтоб ответы совпали, и запросы были валидными
        Для этих целей для каждой пары запрос/ответ можно задать состояние и провайдер при проверке контрактов его задаст
        При этом провайдер это может сделать так как это ему удобно.

        У нас получается:
        1) Команда которая разрабатывает консьюмера может писать быстрые тесты с моками
        2) Команда которая разрабатывает провайдера получает документацию по тому что они хотят, причем в виде тестов,
           Все знают что такое ААА(Arrange Act Assert)?, так вот контракт это Act и Assert и все что требуется от команды провайдера
           написать Arrange.
        3) Мы даже можем првоерить контрактами обратную совместимость

        Как результат мы умеем тестировать интеграции между сервисами (тестировать моки) и нам для этого не нужно окружение!

        [Documentation Driven Development, TDD для API если консьюмер разрабатывается раньше провайдера]
    </blockquote>

    <p>Андрей:</p>
    <blockquote>
        Это звучит уже лучше, но ты же понимаешь
    </blockquote>
</aside>
